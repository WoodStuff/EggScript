using EggScript.Exceptions;
using EggScript.Parsing;
using EggScript.Parsing.Nodes.Expression;
using EggScript.Parsing.Nodes.Expression.Data;
using EggScript.Parsing.Nodes.Statement;

namespace EggScript.Runtime;

/// <summary>
/// Executes the EggScript program.
/// </summary>
internal static class Interpreter
{
	private static readonly string[] operators_dontparseleft = ["="];

	/// <summary>
	/// The declared variables and their values.
	/// </summary>
	private static Dictionary<string, Variable> Variables { get; } = [];

	/// <summary>
	/// Runs an EggScript program based on the abstract syntax tree generated from the <see cref="Parser"/>.
	/// </summary>
	/// <param name="nodes">The list of nodes generated by the <see cref="Parser"/>.</param>
	/// <exception cref="EggRuntimeException">Thrown when a runtime error is encountered.</exception>
	public static void Execute(List<IStatementNode> nodes)
	{
		ExecuteNodes(nodes);

		// post program cleanup
		Variables.Clear();
	}

	/// <summary>
	/// Executes a list of statement nodes.
	/// </summary>
	/// <param name="nodes">The statement nodes.</param>
	private static void ExecuteNodes(List<IStatementNode> nodes)
	{
		foreach (IStatementNode node in nodes)
		{
			ExecuteStatement(node);
		}
	}

	/// <summary>
	/// Executes a statement node.
	/// </summary>
	/// <param name="node">The statement node to execute.</param>
	/// <exception cref="EggRuntimeException">Thrown when an invalid node is detected.</exception>
	internal static void ExecuteStatement(IStatementNode node)
	{
		switch (node)
		{
			case PrintNode printNode:
				Console.WriteLine(GetValue(printNode.Data).StringValue);
				break;

			case VarDeclarationNode varDecNode:
				AddVariable(varDecNode.Name, varDecNode.Type, varDecNode.Constant);
				if (varDecNode.Initialized) ModifyVariable(varDecNode.Name, GetValue(varDecNode.Data), true);
				break;

			case VarAssignmentNode varAssNode:
				ModifyVariable(varAssNode.Name, GetValue(varAssNode.Data));
				break;

			case ConditionalNode conditionalNode:
				IDataNode condition = GetValue(conditionalNode.Condition);
				if (condition is not BooleanNode result) throw new EggRuntimeException("If statement condition is not a boolean");

				if (result.Value) ExecuteNodes(conditionalNode.Body);
				else if (conditionalNode.Otherwise is not null) ExecuteNodes(conditionalNode.Otherwise);
				break;

			default:
				throw new EggRuntimeException($"Invalid node: {node.GetType().Name}");
		}
	}

	/// <summary>
	/// Gets the value of an expression node.
	/// </summary>
	/// <param name="node">The expression node to evaluate.</param>
	/// <returns>The value of the expression.</returns>
	/// <exception cref="EggRuntimeException">Thrown when an invalid node is detected.</exception>
	internal static IDataNode GetValue(IExpressionNode node)
	{
		return node switch
		{
			IDataNode dataNode => dataNode,
			IdentifierNode identifierNode => GetVariable(identifierNode.Name),
			OperatorNode operatorNode => ParseOperator(operatorNode),
			UnaryOpNode unaryOpNode => ParseOperator(unaryOpNode),
			_ => throw new EggRuntimeException($"Tried to get value of an invalid node: {node.GetType().Name}"),
		};
	}

	/// <summary>
	/// Calculates the result of an <see cref="OperatorNode"/>.
	/// </summary>
	/// <param name="node">The operator node to evaluate.</param>
	/// <returns>The result of the operator.</returns>
	/// <exception cref="EggRuntimeException">Thrown when an invalid use of operators is detected, for example wrong data types.</exception>
	private static IDataNode ParseOperator(OperatorNode node)
	{
		string op = node.Operator;
		IDataNode? left = operators_dontparseleft.Contains(op) ? null : GetValue(node.Left);
		IDataNode right = GetValue(node.Right);

		return op switch
		{
			"+" => (left, right) switch
			{
				(NumberNode l, NumberNode r) => l + r,
				(StringNode l, StringNode r) => l + r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"-" => (left, right) switch
			{
				(NumberNode l, NumberNode r) => l - r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"*" => (left, right) switch
			{
				(NumberNode l, NumberNode r) => l * r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"/" => (left, right) switch
			{
				(NumberNode l, NumberNode r) => l / r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"&" => (left, right) switch
			{
				(BooleanNode l, BooleanNode r) => l & r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"|" => (left, right) switch
			{
				(BooleanNode l, BooleanNode r) => l | r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"==" => (left, right) switch
			{
				(StringNode l, StringNode r) => new BooleanNode(l.Value == r.Value),
				(NumberNode l, NumberNode r) => new BooleanNode(l.Value == r.Value),
				(BooleanNode l, BooleanNode r) => new BooleanNode(l.Value == r.Value),
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"!=" => (left, right) switch
			{
				(StringNode l, StringNode r) => new BooleanNode(l.Value != r.Value),
				(NumberNode l, NumberNode r) => new BooleanNode(l.Value != r.Value),
				(BooleanNode l, BooleanNode r) => new BooleanNode(l.Value != r.Value),
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			">" => (left, right) switch
			{
				(NumberNode l, NumberNode r) => l > r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"<" => (left, right) switch
			{
				(NumberNode l, NumberNode r) => l < r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			">=" => (left, right) switch
			{
				(NumberNode l, NumberNode r) => l >= r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"<=" => (left, right) switch
			{
				(NumberNode l, NumberNode r) => l <= r,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"=" => node.Left switch
			{
				IdentifierNode l => ModifyVariable(l.Name, right),
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			_ => throw new EggRuntimeException("Invalid operator"),
		};
	}

	/// <summary>
	/// Calculates the result of an <see cref="UnaryOpNode"/>.
	/// </summary>
	/// <param name="node">The operator node to evaluate.</param>
	/// <returns>The result of the operator.</returns>
	/// <exception cref="EggRuntimeException">Thrown when an invalid use of operators is detected, for example wrong data types.</exception>
	private static IDataNode ParseOperator(UnaryOpNode node)
	{
		string op = node.Operator;
		IDataNode operand = GetValue(node.Operand);

		return op switch
		{
			"+" => operand switch
			{
				NumberNode n => +n,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"-" => operand switch
			{
				NumberNode n => -n,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			"!" => operand switch
			{
				BooleanNode n => !n,
				_ => throw new EggRuntimeException("Invalid data types in operator"),
			},
			_ => throw new EggRuntimeException("Invalid operator"),
		};
	}

	/// <summary>
	/// Declares a variable with the given name and data.
	/// </summary>
	/// <param name="name">The name of the variable.</param>
	/// <param name="data">The variable's value.</param>
	/// <param name="constant">If the variable is a constant.</param>
	/// <exception cref="EggRuntimeException">Thrown when the variable has already been declared.</exception>
	private static void AddVariable(string name, DataType type, bool constant = false)
	{
		Variable var = new(type, constant);
		if (!Variables.TryAdd(name, var)) throw new EggRuntimeException($"Variable {name} was already declared");
	}

	/// <summary>
	/// Gets a variable's value.
	/// </summary>
	/// <param name="name">The name of the variable.</param>
	/// <returns>The variable's value.</returns>
	/// <exception cref="EggRuntimeException">Thrown when the variable has not been declared yet.</exception>
	private static IDataNode GetVariable(string name)
	{
		if (!Variables.TryGetValue(name, out Variable? var)) throw new EggRuntimeException($"Variable {name} was not found");
		if (!var.Initialized) throw new EggRuntimeException($"Variable {name} is uninitialized");
		return var.Data;
	}

	/// <summary>
	/// Assigns a value to a declared variable.
	/// </summary>
	/// <param name="name">The name of the variable.</param>
	/// <param name="data">The value to set the variable to.</param>
	/// <param name="init">If this is a variable initialization (num n = 2) as opposed to an assignment (n = 2).</param>
	/// <returns><paramref name="data"/></returns>
	/// <exception cref="EggRuntimeException">Thrown when the variable has not been declared yet, is a constant variable, or an attempt to change the variable's data type was detected.</exception>
	private static IDataNode ModifyVariable(string name, IDataNode data, bool init = false)
	{
		if (!Variables.TryGetValue(name, out Variable? value)) throw new EggRuntimeException($"Variable {name} was not found");
		if (!init && value.Constant) throw new EggRuntimeException($"Cannot modify constant variable {name}");
		if (value.Type != data.Type) throw new EggRuntimeException($"Cannot change variable {name}'s type (tried to change {value.Type} to {data.Type})");
		Variables[name].Data = data;
		return data;
	}
}