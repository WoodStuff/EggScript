using EggScript.Exceptions;
using EggScript.Parsing.Nodes.Expression;
using EggScript.Parsing.Nodes.Expression.Data;
using EggScript.Parsing.Nodes.Statement;
using EggScript.Tokenization;

namespace EggScript.Parsing;

/// <summary>
/// Parses the source code's tokens into an abstract syntax tree.
/// </summary>
/// <param name="_tokens">The source code's tokens, generated by the <see cref="Tokenizer"/>.</param>
internal partial class Parser(List<Token> _tokens)
{
	#region Fields
	/// <summary>
	/// The "free keywords" that represent booleans.
	/// </summary>
	private static readonly string[] booleans = ["true", "false"];
	/// <summary>
	/// All the binary operators along with their precedence. The higher the number, the more precedence it has.
	/// </summary>
	private static readonly Dictionary<int, string[]> operators = new()
	{
		{ 0, ["=", "+=", "-=", "*=", "/="] },
		{ 1, ["&"] },
		{ 2, ["|"] },
		{ 3, ["==", "!="] },
		{ 4, [">=", "<=", ">", "<"] },
		{ 5, ["+", "-"] },
		{ 6, ["*", "/"] },
	};
	/// <summary>
	/// All the unary operators that go before the expression. These always have higher precedence than any binary operator.
	/// </summary>
	private static readonly string[] unaryOperatorsLeft = ["+", "-", "!"];
	/// <summary>
	/// All the unary operators that go after the expression. These always have higher precedence than any binary operator.
	/// </summary>
	private static readonly string[] unaryOperatorsRight = ["++", "--"];
	/// <summary>
	/// The statements that can't have a semicolon after them. This includes if statements, and later, loops and functions.
	/// </summary>
	private static readonly string[] keywordsNoSemicolons = ["", "if"];
	#endregion

	#region Properties
	/// <summary>
	/// The source code's tokens, generated by the <see cref="Tokenizer"/>.
	/// </summary>
	private List<Token> Tokens { get; } = _tokens;
	/// <summary>
	/// The index of the token next in the queue.
	/// </summary>
	private int Index { get; set; } = 0;
	/// <summary>
	/// The token to be read next.
	/// </summary>
	private Token CurrentToken => Tokens[Index];
	#endregion

	#region Parsing Methods
	/// <summary>
	/// Parses the <see cref="Tokens"/> into an abstract syntax tree.
	/// </summary>
	/// <returns>A list of nodes made from the tokens.</returns>
	public List<IStatementNode> Parse()
	{
		List<IStatementNode> nodes = [];
		while (!Match(TokenType.EOF, out _))
		{
			nodes.Add(ParseStatement());
		}
		return nodes;
	}

	/// <summary>
	/// Parses a statement.
	/// </summary>
	/// <returns>The node corresponding to that statement.</returns>
	/// <exception cref="EggSyntaxException">Thrown when a syntax error is detected.</exception>
	private IStatementNode ParseStatement()
	{
		IStatementNode node;

		if (Match(TokenType.Keyword, out string keyword)) node = ParseKeywordStatement(keyword);
		else if (Match(TokenType.Punctuation, "{")) node = ParseBlock();
		else
		{
			keyword = "exprstatement";
			IExpressionNode expr = ParseExpression();
			node = ParseExprStatement(expr);
		}

		if (!keywordsNoSemicolons.Contains(keyword) && !Match(TokenType.Punctuation, ";")) Throw_Expected(Next().Value, ";");

		return node;
	}

	/// <summary>
	/// Parses a statement starting from a keyword.
	/// </summary>
	/// <param name="keyword">The keyword the statement starts from.</param>
	/// <returns>The node corresponding to that statement.</returns>
	/// <exception cref="EggSyntaxException">Thrown when a syntax error is detected.</exception>
	private IStatementNode ParseKeywordStatement(string keyword)
	{
		IStatementNode node;
		switch (keyword)
		{
			// print(5);
			case "print":
			{
				Expect(TokenType.Punctuation, "(");

				IExpressionNode data = ParseExpression();
				node = new PrintNode(data);

				Expect(TokenType.Punctuation, ")");
				break;
			}

			// var1 thing [num] = 5;
			// var1 thing [num];
			case "var":
			{
				Expect(TokenType.Identifier, out string name); // variable name

				Expect(TokenType.Punctuation, "[");
				Expect(TokenType.FreeKeyword, out string typeString);
				Expect(TokenType.Punctuation, "]");

				DataType type = TypeFromString(typeString);

				if (!Match(TokenType.Operator, "=")) // undeclared variable
				{
					node = new VarDeclarationNode(name, type);
					break;
				}

				IExpressionNode data = ParseExpression();
				node = new VarDeclarationNode(name, type, data);
				break;
			}

			// const thing [num] = 5;
			case "const":
			{
				Expect(TokenType.Identifier, out string name); // variable name

				Expect(TokenType.Punctuation, "[");
				Expect(TokenType.FreeKeyword, out string typeString);
				Expect(TokenType.Punctuation, "]");

				DataType type = TypeFromString(typeString);

				if (!Match(TokenType.Operator, "=")) throw new EggSyntaxException($"Constant variable {name} must be initialized");

				IExpressionNode data = ParseExpression();
				node = new VarDeclarationNode(name, type, data, true);

				break;
			}

			// if x > 5 { ... }
			// if x > 5 { ... } else { ... }
			case "if":
			{
				IExpressionNode condition = ParseExpression();

				BlockNode block = Match(TokenType.Punctuation, "{") ? ParseBlock() : new(ParseStatement());

				BlockNode? otherwise = null;
				if (Match(TokenType.FreeKeyword, "else"))
				{
					otherwise = Match(TokenType.Punctuation, "{") ? ParseBlock() : new(ParseStatement());
				}

				node = new ConditionalNode(condition, block, otherwise);

				break;
			}

			default:
				throw new EggSyntaxException($"Keyword {keyword} is not implemented");
		}
		return node;
	}

	/// <summary>
	/// Parses a statement that is an expression, like a variable assignment statement.
	/// </summary>
	/// <param name="expr">The statement's expression.</param>
	/// <returns>The node corresponding to that statement.</returns>
	/// <exception cref="EggSyntaxException">Thrown when a syntax error is detected.</exception>
	internal static IStatementNode ParseExprStatement(IExpressionNode expr)
	{
		IStatementNode node = expr switch
		{
			OperatorNode { Left: IdentifierNode var1 } operatorNode when operatorNode.Operator == "="
				=> new VarAssignmentNode(var1.Name, operatorNode.Right),
			OperatorNode { Left: IdentifierNode var1 } operatorNode when operatorNode.Operator == "+="
				=> new IncrementNode(var1.Name, "+", operatorNode.Right),
			OperatorNode { Left: IdentifierNode var1 } operatorNode when operatorNode.Operator == "-="
				=> new IncrementNode(var1.Name, "-", operatorNode.Right),
			OperatorNode { Left: IdentifierNode var1 } operatorNode when operatorNode.Operator == "*="
				=> new IncrementNode(var1.Name, "*", operatorNode.Right),
			OperatorNode { Left: IdentifierNode var1 } operatorNode when operatorNode.Operator == "/="
				=> new IncrementNode(var1.Name, "/", operatorNode.Right),

			UnaryOpNode { Operand: IdentifierNode var2 } unaryOpNode when unaryOpNode.Operator == "++"
				=> new IncrementNode(var2.Name, "+", new NumberNode(1)),
			UnaryOpNode { Operand: IdentifierNode var2 } unaryOpNode when unaryOpNode.Operator == "--"
				=> new IncrementNode(var2.Name, "-", new NumberNode(1)),

			_ => throw new EggSyntaxException("Only keywords, assignment, increment or decrement expressions can be used as a statement"),
		};
		return node;
	}

	/// <summary>
	/// Parses an expression.
	/// </summary>
	/// <returns>The node corresponding to that expression.</returns>
	private IExpressionNode ParseExpression()
	{
		IExpressionNode data = ParseOperator();
		return data;
	}

	/// <summary>
	/// Parses an expression that may contain operators.
	/// </summary>
	/// <param name="level">The operator precedence level to start at.</param>
	/// <returns>The node corresponding to that expression.</returns>
	private IExpressionNode ParseOperator(int level = 0)
	{
		IExpressionNode data = GetLowerExpression(level);
		while (Match(TokenType.Operator, out string op, operators[level]))
		{
			IExpressionNode right = GetLowerExpression(level);
			data = new OperatorNode(data, op, right);
		}
		return data;

		// parses the operators with higher precedence
		// e.g. if we're parsing + -, this will parse * /
		IExpressionNode GetLowerExpression(int level)
		{
			if (level == operators.Count - 1)
			{
				return ParseUnary();
			}
			return ParseOperator(level + 1);
		}
	}

	/// <summary>
	/// Parses an expression that may contain unary operators.
	/// </summary>
	/// <returns>The node corresponding to that expression.</returns>
	private IExpressionNode ParseUnary()
	{
		IExpressionNode node;

		// parse left
		if (Match(TokenType.Operator, out string opl, unaryOperatorsLeft))
		{
			IExpressionNode leftValue = ParseUnary();
			node = new UnaryOpNode(opl, leftValue);
			return node;
		}

		// parse right
		node = ParsePrimary();
		while (Match(TokenType.Operator, out string opr, unaryOperatorsRight))
		{
			node = new UnaryOpNode(opr, node);
		}

		return node;
	}

	/// <summary>
	/// Parses some basic data, such as a string, number, identifier or a completely new expression through parentheses.
	/// </summary>
	/// <returns>The node corresponding to that data.</returns>
	private IExpressionNode ParsePrimary()
	{
		Token token = Next();

		IExpressionNode node;
		switch (token.Type)
		{
			case TokenType.String: node = new StringNode(token.Value); break;
			case TokenType.Number: node = new NumberNode(token.Value); break;
			case TokenType.Identifier: node = new IdentifierNode(token.Value); break;

			// booleans
			case TokenType.FreeKeyword:
				if (!booleans.Contains(token.Value)) Throw_Expected(token.Value);
				node = new BooleanNode(token.Value);
				break;

			// parentheses
			case TokenType.Punctuation:
				if (token.Value != "(") Throw_Expected(token.Value);
				node = ParseExpression();
				Expect(TokenType.Punctuation, ")");
				break;

			default:
				Throw_Expected(token.Value);
				throw new Exception(); // required because C# doesn't realize Throw_Expected always throws
		}
		return node;
	}

	/// <summary>
	/// Parses a block statement, which is a list of statements enclosed by { }. Assumes the { was already matched.
	/// </summary>
	/// <returns>A list of statements in the block.</returns>
	private BlockNode ParseBlock()
	{
		BlockNode block = new();

		while (!Match(TokenType.Punctuation, "}"))
		{
			block.Add(ParseStatement());
		}

		return block;
	}
	#endregion

	#region Static Parsing Methods
	/// <summary>
	/// Parses a statement.
	/// </summary>
	/// <param name="source">The code of the statement.</param>
	/// <returns>The statement node.</returns>
	internal static IStatementNode ParseStatement(string source)
	{
		List<Token> tokens = Tokenizer.Tokenize(source);

		Parser parser = new(tokens);
		IStatementNode node = parser.ParseStatement();

		return node;
	}

	/// <summary>
	/// Parses an expression.
	/// </summary>
	/// <param name="source">The code of the expression.</param>
	/// <returns>The expression node.</returns>
	internal static IExpressionNode ParseExpression(string source)
	{
		List<Token> tokens = Tokenizer.Tokenize(source);

		Parser parser = new(tokens);
		IExpressionNode node = parser.ParseExpression();

		return node;
	}
	#endregion
}