using EggScript.Exceptions;
using EggScript.Parsing.Nodes;
using EggScript.Tokenization;

namespace EggScript.Parsing;

/// <summary>
/// Parses the source code's tokens into an abstract syntax tree.
/// </summary>
/// <param name="tokens">The source code's tokens, generated by the <see cref="Tokenizer"/>.</param>
internal class Parser(List<Token> tokens)
{
	/// <summary>
	/// The source code's tokens, generated by the <see cref="Tokenizer"/>.
	/// </summary>
	private List<Token> Tokens { get; } = tokens;
	/// <summary>
	/// The index of the token next in the queue.
	/// </summary>
	private int Index { get; set; } = 0;
	/// <summary>
	/// The token to be read next.
	/// </summary>
	private Token CurrentToken => Tokens[Index];

	/// <summary>
	/// Parses the <see cref="Tokens"/> into an abstract syntax tree.
	/// </summary>
	/// <returns>A list of nodes make from the tokens.</returns>
	public List<INode> Parse()
	{
		List<INode> nodes = [];
		while (!Match(TokenType.EOF, out _))
		{
			nodes.Add(ParseStatement());
		}
		return nodes;
	}

	/// <summary>
	/// Parses a statement.
	/// </summary>
	/// <returns>The node corresponding to that statement.</returns>
	/// <exception cref="EggScriptException">Thrown when a syntax error is detected.</exception>
	public IStatementNode ParseStatement()
	{
		if (!Match(TokenType.Keyword, "print")) throw new EggScriptException("Statement must start from a keyword");
		if (!Match(TokenType.Punctuation, "(")) throw new EggScriptException("( expected");
		Token token = Next();
		PrintNode node = token.Type switch
		{
			TokenType.String => new(token.Value),
			TokenType.Number => new(token.Value),
			_ => throw new EggScriptException("String expected"),
		};
		if (!Match(TokenType.Punctuation, ")")) throw new EggScriptException(") expected");

		if (!Match(TokenType.Punctuation, ";")) throw new EggScriptException("; expected");

		return node;
	}

	/// <summary>
	/// Tries to detect what token is next based on the type and advances the queue if it's correct.
	/// </summary>
	/// <param name="type">What type the next token is predicted to be.</param>
	/// <param name="value">If successful, the value of the token.</param>
	/// <returns>If the next token in the queue is of type <paramref name="type"/>.</returns>
	private bool Match(TokenType type, out string value)
	{
		value = "";
		if (CurrentToken.Type != type) return false;

		value = CurrentToken.Value;
		Index++;
		return true;
	}

	/// <summary>
	/// Tries to detect what token is next based on the type and value and advances the queue if it's correct.
	/// </summary>
	/// <param name="type">What type the next token is predicted to be.</param>
	/// <param name="value">What value the next token is predicted to have.</param>
	/// <returns>If the next token in the queue is of type <paramref name="type"/> and has value <paramref name="value"/>.</returns>
	private bool Match(TokenType type, string value)
	{
		if (CurrentToken.Type != type || CurrentToken.Value != value) return false;

		Index++;
		return true;
	}

	/// <summary>
	/// Gets the next token in the queue and advances the queue.
	/// </summary>
	/// <returns>The next token.</returns>
	private Token Next()
	{
		Token token = CurrentToken;
		Index++;
		return token;
	}
}